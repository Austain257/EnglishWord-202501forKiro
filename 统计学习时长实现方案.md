以下方案面向开发团队，覆盖数据建模、接口协议、前端实现、异常兜底及性能优化，确保“只在指定学习页计时，展示【当天学习时长/XhYmin】【累计学习时长/XhYmin】”的目标可交付、可扩展。

---

## 1. 需求范围与约束
1. **触发条件**：仅当用户进入指定学习场景（如 WordReview、WordDictation、WordGame、WordOption、WordLearning 等）时开始计时。其它页面不计时。
2. **停止条件**：离开学习场景、页面不可见、关闭页面、退出登录、网络断开、Token 失效、浏览器崩溃等必须立即或尽快停止/归档计时。
3. **展示指标**：  
   - 当天学习时长（累计到今日 00:00–当前的有效时长）。  
   - 累计学习时长（注册以来所有有效时长）。  
   - 两者都需以 `XhYmin` 形式展示，适配 PC/移动端 UI。
4. **防抖**：短暂停留或反复进入退出不应产生大量无效 session，确保数据准确、后端压力可控。
5. **系统限制**：后端为 Java Spring Boot（端口 8080）；前端 Vue 3 + Pinia；所有接口通过 `http://192.168.43.106/api` 调用；用户必须已选择课本（router meta `requiresBook` 已保障 @/src/router/index.js#33-168）。

---

## 2. 数据建模（MySQL）

### 2.1 会话表 `user_study_session`
| 字段                    | 类型        | 说明                                                         |
| ----------------------- | ----------- | ------------------------------------------------------------ |
| `id`                    | BIGINT PK   | 自增                                                         |
| `user_id`               | BIGINT      | 用户 ID（必填）                                              |
| `book_id`               | BIGINT      | 当前课本 ID（来自 authStore.currentBookId）                  |
| `study_scene`           | VARCHAR(64) | 学习场景编码（如 `word_review_first`）                       |
| `start_time`            | DATETIME    | 会话开始                                                     |
| `end_time`              | DATETIME    | 会话结束；未结束为 NULL                                      |
| `duration_sec`          | INT         | 结束后写入秒数（后端以 end-start 计算，向上取整到分钟时再展示） |
| `status`                | TINYINT     | 0=running,1=finished,2=force_closed                          |
| `last_heartbeat`        | DATETIME    | 最近一次心跳，辅助兜底                                       |
| `client_meta`           | JSON        | 可选：记录设备、浏览器、pause/resume 次数                    |
| `created_at/updated_at` | DATETIME    | 维护字段                                                     |

索引：`idx_user_date`（user_id + start_time），`idx_status`（status），`idx_heartbeat`（last_heartbeat 用于扫描超时会话）。

### 2.2 汇总表（可选）`user_study_stat`
- 字段：`user_id`, `stat_date`, `day_total_sec`, `total_sec`, `updated_at`。
- 通过写入 session 时实时 upsert，或由定时任务离线聚合。

---

## 3. 后端服务设计（Spring Boot, 8080）

### 3.1 DTO/实体
- `StudySessionDTO`：start 请求体含 `studyScene`；finish 请求体含 `sessionId`、`actualDurationSec`（可选）等。
- `StudyStatVO`：提供给前端展示的今日/累计秒数等信息。

### 3.2 Mapper & Service
- `StudySessionRepository`：基本增改查。
- `StudySessionService`：
  - `startSession(userId, bookId, scene)`  
    - 若存在 `status=RUNNING` 的旧 session，先调用 `forceFinishSession`（end=now，status=2）。  
    - 插入新记录并返回 `sessionId`。
  - `heartbeat(sessionId)`  
    - 更新 `last_heartbeat`；可用于判定用户仍活跃。
  - `finishSession(sessionId, endTime, clientDurationSec)`  
    - endTime 默认 `now`。  
    - duration = max(clientDurationSec, endTime-startTime, 0)。  
    - 若 duration < 30 秒可直接丢弃或合并（可配置）。
  - `autoCloseTimeoutSessions(timeoutMinutes)`  
    - 定时任务扫描 `status=0` 且 `now - last_heartbeat > timeout` 的记录，调用 `forceFinishSession`。

### 3.3 Controller（`/api/study`）
| 接口                 | 方法 | 描述                                                         |
| -------------------- | ---- | ------------------------------------------------------------ |
| `/session/start`     | POST | Body: `{ studyScene }`; 返回 `{ sessionId, serverTime }`     |
| `/session/heartbeat` | POST | Body: `{ sessionId }`; 返回 200                              |
| `/session/finish`    | POST | Body: `{ sessionId, endTime?, clientDurationSec? }`; 返回 `{ dayTotalSec, totalSec }` 便于前端即时刷新 |
| `/stat/today`        | GET  | 返回 `{ dayTotalSec, totalSec, breakdown? }`                 |
| `/stat/history`      | GET  | 可选，返回最近 7/30 天曲线                                   |

- 所有接口使用现有 Auth 过滤器校验 token；`userId` 从 token 中取。  
- `bookId` 通过与 authStore 一致的字段注入（请求头或 session）或由前端传递，后端需验证其确实属于当前用户可访问的课本。  
- 响应走统一 Result 模型，方便前端 Toast/错误处理。

### 3.4 定时任务
- 每 5 分钟 `autoCloseTimeoutSessions(3)`：若 3 分钟无心跳则结束，防止浏览器崩溃导致 session 悬挂。
- （可选）每天 00:05 触发汇总任务，把上一日数据刷入 `user_study_stat`，供 BI 使用。

---

## 4. 前端实现（Vue 3 + Pinia）

### 4.1 元信息
- 在 [src/router/index.js](cci:7://file:///d:/develop/code-file/kiro/EnglishWord-202501forKiro/English_front_vue/src/router/index.js:0:0-0:0) 中为学习页面添加 `meta.studyScene`（如 `meta: { requiresAuth: true, requiresBook: true, studyScene: 'word_review_first' }`）。  
- 通过该字段统一判定是否需要计时（现有 requiresBook 逻辑仍在 @/src/router/index.js#33-168）。

### 4.2 Study Tracker Store
新建 `src/stores/studyTracker.js`（Pinia）：
```ts
state: () => ({
  sessionId: null,
  studyScene: null,
  startTime: null,
  elapsedMs: 0,
  timerId: null,
  paused: false,
  lastVisibility: document.visibilityState,
})
```
Actions：
1. `start(scene)`  
   - 若已有 session，先 `finish('switchScene')`。  
   - 调用 `studyService.startSession(scene)`，保存 `sessionId/startTime`。  
   - 启动 `timerId = setInterval(() => elapsedMs += 1000, 1000)`。  
   - 立即设置 `paused=false`，并启动 `heartbeat`（setInterval 每 60 秒调用）。
2. `pause(reason)`  
   - `if (timerId) clearInterval(timerId)` 并置 `paused=true`。  
   - 可记录 `pauseReasons` 方便调试。
3. `resume()`  
   - 若 `sessionId` 存在且 `paused=true`，重新启动 `timerId` 并发送一次 heartbeat。
4. `finish(source)`  
   - 清理 interval + heartbeat。  
   - 计算 `clientDurationSec = Math.round(elapsedMs / 1000)`。  
   - 调用 `studyService.finishSession(sessionId, clientDurationSec, source)`，接口返回的最新统计数据写入 `studyStatStore`。  
   - 重置 state。
5. `handleUnexpectedExit()`  
   - 在 `beforeunload`、`logout`、`token` 过期等场景调用。  
   - 使用 `navigator.sendBeacon` 调 finish，确保请求在页面关闭前发出。  
   - 若 sendBeacon 不可用则降级为同步 `XMLHttpRequest`。

### 4.3 页面/路由集成
1. **router.afterEach**：  
   ```ts
   router.afterEach((to, from) => {
     const tracker = useStudyTrackerStore()
     if (from.meta?.studyScene && from.meta.studyScene !== to.meta?.studyScene) {
       tracker.finish('leaveRoute')
     }
     if (to.meta?.studyScene) {
       tracker.start(to.meta.studyScene)
     }
   })
   ```
2. **页面级控制**：对于 WordGame/WordOption 类互动页面，可在“开始按钮”点击时调用 `tracker.start(scene)`，在“结束/失败”时调用 `tracker.finish('gameOver')`，路由离开时仍调用 `finish` 兜底。
3. **浏览器事件**：  
   - `document.addEventListener('visibilitychange', ...)`：隐藏时 `pause('visibility')`，恢复时 `resume()`。  
   - `window.addEventListener('beforeunload', tracker.handleUnexpectedExit)`。  
   - `window.addEventListener('offline', () => tracker.pause('offline'))`；`online` 后可提示用户重新进入。  
   - 在 `useAuthStore().logout` 内调用 `tracker.handleUnexpectedExit()`，防止残留会话。

### 4.4 学习统计展示
- 新增 `useStudyStatStore`，持久化 `todaySec`、`totalSec`。  
- 在 Home.vue（或专门的 Dashboard）新增两个卡片：  
  - `今日学习时长` → `formatDuration(todaySec)`  
  - `累计学习时长` → `formatDuration(totalSec)`  
    `formatDuration` 规则：`const hours = Math.floor(sec / 3600); const minutes = Math.floor((sec % 3600) / 60); return \`\${hours}h\${minutes}min\``。  
- 在 `studyService.finishSession` 和 `studyStatStore.refresh()` 后更新 UI；初次进入首页时调用 `GET /study/stat/today` 初始化。

### 4.5 防抖策略
- 前端：`start` 后设定最小持续时长阈值，如 `<15s` 的 session 标记 `tooShort=true`，finish 时发送该标志，后端可直接丢弃。  
- 后端：`finishSession` 中 `if durationSec < 15 then return success without inserting duration`。  
- 心跳：只有 session 存续时才调用；退出后必须立即停止，避免无意义请求。

---

## 5. 异常&兜底策略

| 场景                      | 处理方式                                                     |
| ------------------------- | ------------------------------------------------------------ |
| 用户切到其他标签页/最小化 | `visibilitychange` 触发 `pause`；恢复时 `resume`（可在恢复后等待 3 秒再继续，避免频繁切换造成抖动）。 |
| 浏览器关闭/崩溃           | `beforeunload` + sendBeacon；后台心跳超时（3 分钟）自动结束。 |
| 退出登录                  | `logout` 前调用 `handleUnexpectedExit`。                     |
| 网络断开                  | `offline` 事件 pause，并记录 `offline` 状态；若 60 秒内未恢复可自动 finish（带 `status=force_closed`）。 |
| 多个学习页面同时打开      | start 时先 finish 旧 session；如需支持多窗口，可在 session 表增加 `client_id` 区分，但推荐限制为单 session，避免重复计时。 |
| 接口失败                  | 前端 toast + 重试；若 finish 调用失败，可在本地缓存待补偿队列，下次启动应用时补发。 |

---

## 6. 性能与高可用
1. **接口幂等**：start/finish 携带 `sessionId`，后端对重复请求返回相同结果，避免网络抖动导致数据重复。
2. **数据库压力**：  
   - 会话结束才写入 duration，start 仅插入一条记录；  
   - heartbeat 写入频率上限 1 分钟/次，可通过 Redis 缓存本地状态减少 DB IO；  
   - 汇总表提供最快查询今日/累积数据，减少对 session 表的聚合压力。
3. **批处理**：finish 接口返回最新统计，避免前端额外再拉一次 stat。  
4. **安全**：所有请求携带 token；studyScene/ bookId 后端验证，防止伪造计时。

---

## 7. 测试计划
1. **单元测试**  
   - `StudySessionService.start/finish/autoClose` 行为覆盖。  
   - 路由钩子逻辑（可通过 Vue Router 测试实例模拟）。
2. **集成测试**  
   - 前端 E2E：进入 WordReview 30 秒 → 切换到首页 → 确认 session 被 finish，统计更新。  
   - 异常流程：断网、关闭标签页、重复 login 等。
3. **性能测试**  
   - 并发 1k 用户同时发 heartbeat/finish，确认 DB、接口响应在 SLA 内。  
   - 定时任务扫描 10k 未结束 session 的耗时。

---

## 8. 推进步骤
1. **后端**：  
   - 新增数据表 → 实现实体、Repository、Service → Controller → 定时任务 → 单元测试 → 接口文档（Swagger）。  
2. **前端**：  
   - 建立 `studyTrackerStore` + `studyStatStore` → 接入 router 钩子 & 页面事件 → 调用后端接口 → UI 展示组件 → E2E 测试。  
3. **联调**：  
   - 本地环境模拟多个学习场景进出，检查统计是否准确。  
4. **上线**：  
   - 数据表迁移脚本。  
   - 后端部署（8080）。  
   - 前端构建并验证。  
   - 监控：对 `study/session` 接口加 Prometheus/Log 统计，确保异常可见。

---

按照以上方案执行，可在保证性能和可维护性的前提下，实现“指定页面计时 + 今日/累计统计 + 全场景兜底”的高质量上线版本，满足交付要求。





# 数据库实现

结合当前库结构（参考 @/English_back_java/src/new_database02.sql#12-225 中 `users`、`user_books` 的定义），下面给出可直接执行的建表 + 触发器方案，确保：

1. 仅引用已有主表（`users`,`user_books`），通过外键约束绑定。
2. 统一维护运行中会话与统计表，触发器自动防止多活、自动汇总。
3. 精细索引（按用户/日期/状态/场景）以满足高并发查询与巡检。

------

### 1. 汇总表（依赖触发器，先建）

```
DROP TABLE IF EXISTS `user_study_daily`;
CREATE TABLE `user_study_daily` (
    `user_id`      BIGINT      NOT NULL COMMENT '用户ID',
    `stat_date`    DATE        NOT NULL COMMENT '统计日期',
    `total_sec`    INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '当日累计秒数',
    `updated_at`   DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
                                ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '最后更新时间',
    PRIMARY KEY (`user_id`, `stat_date`),
    KEY `idx_user_study_daily_updated` (`updated_at`),
    CONSTRAINT `fk_user_study_daily_user`
        FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户每日学习时长';

DROP TABLE IF EXISTS `user_study_summary`;
CREATE TABLE `user_study_summary` (
    `user_id`    BIGINT        NOT NULL COMMENT '用户ID',
    `total_sec`  BIGINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '累计学习秒数',
    `updated_at` DATETIME(3)   NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
                              ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '最后更新时间',
    PRIMARY KEY (`user_id`),
    CONSTRAINT `fk_user_study_summary_user`
        FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户学习总时长';
```

------

### 2. 会话表 `user_study_session`

```
DROP TABLE IF EXISTS `user_study_session`;
CREATE TABLE `user_study_session` (
    `id`              BIGINT        NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `user_id`         BIGINT        NOT NULL COMMENT '用户ID',
    `book_id`         BIGINT        NOT NULL COMMENT '当前课本ID',
    `study_scene`     VARCHAR(64)   NOT NULL COMMENT '学习场景编码（路由/模式）',
    `start_time`      DATETIME(3)   NOT NULL COMMENT '会话开始时间',
    `end_time`        DATETIME(3)            DEFAULT NULL COMMENT '会话结束时间',
    `duration_sec`    INT UNSIGNED           DEFAULT NULL COMMENT '会话总秒数',
    `status`          TINYINT       NOT NULL DEFAULT 0 COMMENT '0进行中 1已结束 2强制结束',
    `last_heartbeat`  DATETIME(3)            DEFAULT NULL COMMENT '最近心跳时间',
    `source`          VARCHAR(32)            DEFAULT 'ROUTE' COMMENT '触发来源（路由/组件/自动）',
    `client_meta`     JSON                   DEFAULT NULL COMMENT '前端上报细节',
    `created_at`      DATETIME(3)   NOT NULL DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    `updated_at`      DATETIME(3)   NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
                                   ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    PRIMARY KEY (`id`),
    CONSTRAINT `fk_study_session_user`
        FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
    CONSTRAINT `fk_study_session_book`
        FOREIGN KEY (`book_id`) REFERENCES `user_books`(`id`) ON DELETE CASCADE,
    CONSTRAINT `chk_duration_non_negative`
        CHECK (`duration_sec` IS NULL OR `duration_sec` >= 0),

    KEY `idx_session_user_start` (`user_id`, `start_time`),
    KEY `idx_session_status` (`status`, `last_heartbeat`),
    KEY `idx_session_scene` (`study_scene`, `user_id`),
    KEY `idx_session_book` (`book_id`, `status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学习会话表';
```

> **说明**
>
> - `status`：0=运行中，1=正常结束，2=后端或心跳超时强制结束。
> - `last_heartbeat` 支持后台任务扫描长时间无心跳的会话。
> - JSON 字段存端事件（如 pause/resume 次数）便于审计。

------

### 3. 触发器

#### 3.1 防止并发会话 & 初始化心跳

```
DELIMITER $$
DROP TRIGGER IF EXISTS `trg_user_study_session_bi`$$
CREATE TRIGGER `trg_user_study_session_bi`
BEFORE INSERT ON `user_study_session`
FOR EACH ROW
BEGIN
    IF NEW.status = 0 THEN
        IF EXISTS (SELECT 1 FROM `user_study_session`
                   WHERE user_id = NEW.user_id AND status = 0) THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = '已有进行中的学习会话，需先结束后再创建';
        END IF;
        IF NEW.last_heartbeat IS NULL THEN
            SET NEW.last_heartbeat = NEW.start_time;
        END IF;
    END IF;
END$$
DELIMITER ;
```

#### 3.2 更新时保持单活

```
DELIMITER $$
DROP TRIGGER IF EXISTS `trg_user_study_session_bu`$$
CREATE TRIGGER `trg_user_study_session_bu`
BEFORE UPDATE ON `user_study_session`
FOR EACH ROW
BEGIN
    IF NEW.status = 0 THEN
        IF EXISTS (SELECT 1 FROM `user_study_session`
                   WHERE user_id = NEW.user_id AND status = 0 AND id <> OLD.id) THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = '该用户已有其他进行中的学习会话';
        END IF;
        IF NEW.last_heartbeat IS NULL THEN
            SET NEW.last_heartbeat = NEW.start_time;
        END IF;
    END IF;
END$$
DELIMITER ;
```

#### 3.3 会话结束后自动汇总

```
DELIMITER $$
DROP TRIGGER IF EXISTS `trg_user_study_session_au`$$
CREATE TRIGGER `trg_user_study_session_au`
AFTER UPDATE ON `user_study_session`
FOR EACH ROW
BEGIN
    IF OLD.status <> 1 AND NEW.status = 1 AND NEW.duration_sec IS NOT NULL THEN
        -- 更新每日统计
        INSERT INTO `user_study_daily` (`user_id`, `stat_date`, `total_sec`, `updated_at`)
        VALUES (NEW.user_id, DATE(NEW.end_time), NEW.duration_sec, NOW(3))
        ON DUPLICATE KEY UPDATE
            `total_sec` = `total_sec` + NEW.duration_sec,
            `updated_at` = NOW(3);

        -- 更新累计总时长
        INSERT INTO `user_study_summary` (`user_id`, `total_sec`, `updated_at`)
        VALUES (NEW.user_id, NEW.duration_sec, NOW(3))
        ON DUPLICATE KEY UPDATE
            `total_sec` = `total_sec` + NEW.duration_sec,
            `updated_at` = NOW(3);
    END IF;
END$$
DELIMITER ;
```

> 如需对 “强制结束” 也计入统计，可在条件里加 `OR NEW.status = 2`；若需过滤时长过短的会话，可在触发器中判断 `NEW.duration_sec >= 15` 再写入统计。

------

### 4. 使用建议

1. **会话写入**：后端 `start` 时插入 status=0；前端/任务在 `finish` 时更新 end_time、duration_sec、status=1。
2. **超时兜底**：定时任务（如每 5 分钟）扫描 `status=0 AND TIMESTAMPDIFF(MINUTE,last_heartbeat,NOW()) > 3` 的记录，更新为 `status=2` 并补写 duration。
3. 查询：
   - 今日时长 → `SELECT total_sec FROM user_study_daily WHERE user_id=? AND stat_date=CURDATE()`
   - 累计时长 → `SELECT total_sec FROM user_study_summary WHERE user_id=?`
4. **扩展**：若需分场景统计，可增设 `user_study_daily_scene` 表并在触发器里按 `study_scene` 聚合。

该方案完全兼容现有库结构、具备数据完整性约束与自动汇总能力，适合作为“学习会话”落地实现。





# 数据库的实现初衷

1. **分层存储保证性能与扩展性**  
   - `user_study_session` 记录每次学习会话的明细，便于追踪具体场景、心跳、异常等。  
   - `user_study_daily` 与 `user_study_summary` 做汇总，查询“今日/累计时长”时只需扫聚合表，避免在大规模会话表上频繁聚合，保证高性能并支持后续 BI 分析。

2. **数据完整性与联动**  
   - 会话表通过外键直接绑定 `users`、`user_books`，确保只有真实用户和课本才会产生学习记录，系统约束更清晰。  
   - 当用户被删除或课本下架时，级联删除可自动清理相关会话和统计，维护数据一致性。

3. **触发器实现自动化处理**  
   - **`trg_user_study_session_bi/bu`**：插入或更新时检测同一用户是否已有运行中会话，防止多活导致时长重复统计，并初始化 `last_heartbeat`。  
   - **`trg_user_study_session_au`**：会话结束后自动向日统计、总统计写入，不需要额外定时任务或应用层复杂逻辑，保证任何结束流程（正常/强制）都能同步更新汇总数据。  
   - 触发器是数据库层的“保险丝”，即便后端逻辑遗漏，也能阻止脏数据和漏统计。

4. **维护与监控友好**  
   - 汇总表让运维/产品可以直接用 SQL 统计用户每日活跃学习时长；  
   - 触发器保证汇总表始终和会话明细同步，减少人工干预成本。

综上，这种结构能同时兼顾**准确性、性能与可维护性**，适合当前项目长远发展。

